#include "xpn_lib.h"
//#include <stddef.h>
//#include <sys/stat.h>

int   xpn_adaptor_initCalled = 0 ;
char *xpn_adaptor_flog_name  = "/tmp/EXPAND.LOG" ;
char *xpn_adaptor_partition_prefix = "/xpn/" ;
int   xpn_adaptor_fdshift = 64;

char *varenv;



void xpn_adaptor_log ( char * msg, ... )
{
	FILE *flog;
	va_list vargs;

	va_start(vargs,msg);
	flog = fopen(xpn_adaptor_flog_name,"a+");
	if (NULL != flog) {
		vfprintf(flog,msg,vargs);
		fclose(flog);
	}
	va_end(vargs);
}

void xpn_adaptor_keepInit ( void )
{
	int ret,i;

#ifdef DEBUG
	printf("xpn_init:\n");
#endif
	if (0==xpn_adaptor_initCalled)
	{
		ret = xpn_init();
		if (ret < 0)
		{
			printf("xpn_init: Expand couldn't be initialized\n");
			/*xpn_adaptor_log("xpn_init: Expand couldn't be initialized\n");*/
			xpn_adaptor_initCalled = 0;
		}
		else
		{
			xpn_adaptor_initCalled = 1;
		}
		for(i=0;i<MAX_FDS;i++) fdstable[i]=-1;
		for(i=0;i<MAX_DIRS;i++) fdsdirtable[i]=-1;
	}
}

int insFdTable(int fd)
{
	int i;

#ifdef DEBUG
	printf("insFdTable fd = %d\n",fd);
#endif
	for(i=0;i<MAX_FDS;i++)
	{
#ifdef DEBUG
		printf("fdstable[%d]=%d\n",i,fdstable[i]);
#endif
		if(fdstable[i]==-1)
		{
			fdstable[i]=fd;
			return(i);
		}
	}
	return(-1);
}

int open(const char *path, int flags, ...)
{
	int (* new_open1)(char *, int , mode_t );
	int (* new_open2)(char *, int );
	va_list ap;
	int perm,fd,fdret;

	va_start(ap, flags);
	perm = va_arg(ap, mode_t);
	va_end(ap);

#ifdef DEBUG
	printf("antes de open.... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("1)El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
#ifdef DEBUG
	printf("El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(perm != 0)
		{
			printf("perm != 0");
			//fd=xpn_open(path+strlen(xpn_adaptor_partition_prefix),flags,perm);
			fd=xpn_open((char *)(path+strlen(xpn_adaptor_partition_prefix)),flags,perm);
			//fd=xpn_open((char *)(path),flags,perm);
		}
		else
		{
			printf("perm == 0");
			//fd=xpn_open(path+strlen(xpn_adaptor_partition_prefix),flags);
			fd=xpn_open((char *)(path+strlen(xpn_adaptor_partition_prefix)),flags);
			//fd=xpn_open((char *)(path),flags);
		}
		if(fd<0)
		{
			return(-1);
		}
		fdret=insFdTable(fd+PLUSXPN);
		if(fdret==-1)
		{
			return(-1);
		}
		return(fdret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
#ifdef DEBUG
		printf("El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
		printf("perm = %d\n",perm);
#endif
		if(perm != 0)
		{
			//new_open1=dlsym(RTLD_NEXT,"open");
			new_open1=(int (*)(char *, int , mode_t ))dlsym(RTLD_NEXT,"open");
			if(new_open1==NULL){
#ifdef DEBUG
				printf("open1 = NULL\n");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes open1\n");
#endif
			fd=new_open1((char *)path,flags,perm);
			if(fd<0){
#ifdef DEBUG
				printf("open1 = %d\n",fd);
				perror("open1");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes insertar en tabla\n");
#endif
			fdret=insFdTable(fd);
			if(fdret==-1) {
				return(-1);
			}
			return(fdret);
		}
		else
		{
			//new_open2=dlsym(RTLD_NEXT,"open");
			new_open2=(int (*)(char *, int ))dlsym(RTLD_NEXT,"open");
			if(new_open2==NULL)
			{
#ifdef DEBUG
				printf("open2 = NULL\n");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes open2\n");
#endif
			fd=new_open2((char *)path,flags);
			if(fd<0){
				return(-1);
			}
			fdret=insFdTable(fd);
			if(fdret==-1)
			{
			      return(-1);
			}
			return(fdret);
		}
	}// Else
}

int open64(const char *path, int flags, ...)
{
	int (* new_open1)(char *, int , mode_t );
	int (* new_open2)(char *, int );
	va_list ap;
	int perm,fd,fdret;

	va_start(ap, flags);
	perm = va_arg(ap, mode_t);
	va_end(ap);

#ifdef DEBUG
	printf("antes de open64.... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("1)El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
#ifdef DEBUG
	printf("El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(perm != 0)
		{
			printf("perm != 0");
			//fd=xpn_open(path+strlen(xpn_adaptor_partition_prefix),flags,perm);
			fd=xpn_open((char *)(path+strlen(xpn_adaptor_partition_prefix)),flags,perm);
			//fd=xpn_open((char *)(path),flags,perm);
		}
		else
		{
			printf("perm == 0");
			//fd=xpn_open(path+strlen(xpn_adaptor_partition_prefix),flags);
			fd=xpn_open((char *)(path+strlen(xpn_adaptor_partition_prefix)),flags);
			//fd=xpn_open((char *)(path),flags);
		}
		if(fd<0)
		{
			return(-1);
		}
		fdret=insFdTable(fd+PLUSXPN);
		if(fdret==-1)
		{
			return(-1);
		}
		return(fdret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
#ifdef DEBUG
		printf("El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
		printf("perm = %d\n",perm);
#endif
		if(perm != 0)
		{
			//new_open1=dlsym(RTLD_NEXT,"open");
			new_open1=(int (*)(char *, int , mode_t ))dlsym(RTLD_NEXT,"open64");
			if(new_open1==NULL){
#ifdef DEBUG
				printf("open1 = NULL\n");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes open1\n");
#endif
			fd=new_open1((char *)path,flags,perm);
			if(fd<0){
#ifdef DEBUG
				printf("open1 = %d\n",fd);
				perror("open1");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes insertar en tabla\n");
#endif
			fdret=insFdTable(fd);
			if(fdret==-1) {
				return(-1);
			}
			return(fdret);
		}
		else
		{
			//new_open2=dlsym(RTLD_NEXT,"open");
			new_open2=(int (*)(char *, int ))dlsym(RTLD_NEXT,"open64");
			if(new_open2==NULL)
			{
#ifdef DEBUG
				printf("open2 = NULL\n");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes open2\n");
#endif
			fd=new_open2((char *)path,flags);
			if(fd<0){
				return(-1);
			}
			fdret=insFdTable(fd);
			if(fdret==-1)
			{
			      return(-1);
			}
			return(fdret);
		}
	}// Else
}

int close(int fd){
	int (* new_close)(int);
	int ret;
#ifdef DEBUG
	int i;
#endif

#ifdef DEBUG
	printf("antes de close....\n");
	for(i=0;i<10;i++) printf("fdstable[%d]=%d\n",i,fdstable[i]);
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fd]>=PLUSXPN)
	{
		ret=xpn_close(fdstable[fd]-PLUSXPN);
		if(ret==0) fdstable[fd]=-1;	// This normally will be executed, but if close
						// fails, ret<0, and we don't want to lose the
						// reference to the handler yet
		return(ret);
	}
	else // Not an XPN partition. We must link with the standard library
	{
		//new_close=dlsym(RTLD_NEXT,"close");
		new_close=(int (*)(int))dlsym(RTLD_NEXT,"close");
#ifdef DEBUG
		printf("close: dlsym devuelve %d\n",(int)new_close);
#endif
		if(new_close==NULL){
			//printf("close: dlsym devuelve 0\n");
			return(-1);
		}
		ret=new_close(fdstable[fd]);
#ifdef DEBUG
		printf("close: new_close devuelve %d\n",ret);
#endif
		if(ret==0) fdstable[fd]=-1;	// This normally will be executed, but if close
						// fails, ret<0, and we don't want to lose the
						// reference to the handler yet
		//ret=syscall(6,fdstable[fd]);
		//printf("close: syscall(6,fdstable[%d]=%d) devuelve %d\n",fd,fdstable[fd],ret);
		return(ret);
	}// Else
}

int creat(const char *path, mode_t mode)
{
	int (* new_creat)(const char *, mode_t );
	int fd,fdret;
#ifdef DEBUG
	int i;
#endif

#ifdef DEBUG
	printf("antes de creat....\n");
#endif

	xpn_adaptor_keepInit ();//FALTABA//////////////////////////////////////

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
#ifdef DEBUG
		printf("ES EXPAND!\n");
#endif
		fd=xpn_creat((char *)(path+strlen(xpn_adaptor_partition_prefix)),mode);
#ifdef DEBUG
		printf("El archivo es %s",(char *)(path+strlen(xpn_adaptor_partition_prefix)));///////////////
#endif
		if(fd<0){
#ifdef DEBUG
			printf("xpn_creat devuelve fd<0: %d\n",fd);
#endif
			return(-1);
		}
		fdret=insFdTable(fd+PLUSXPN);
		if(fdret==-1){
#ifdef DEBUG
			printf("(Es xpn) insFdTable devuelve fdret=-1\n");
#endif
			return(-1);
		}
		return(fdret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
#ifdef DEBUG
		printf("NO ES EXPAND!\n");
#endif
		//new_creat=dlsym(RTLD_NEXT,"creat");
		new_creat=(int (*)(const char *, mode_t ))dlsym(RTLD_NEXT,"creat");
		if(new_creat==NULL)
		{
#ifdef DEBUG
			printf("dlsym devuelve new_creat==NULL\n");
#endif
			return(-1);
		}
		fd=new_creat(path,mode);
		//printf("fd=new_creat(path,mode) devuelve %d\n",fd);
		if(fd<0)
		{
#ifdef DEBUG
			printf("new_creat devuelve fd=%d\n",fd);
#endif
			return(-1);
		}
		fdret=insFdTable(fd);
#ifdef DEBUG
		printf("dentro de creat\n");
		for(i=0;i<10;i++) printf("fdstable[%d]=%d\n",i,fdstable[i]);
#endif
		if(fdret==-1)
		{
#ifdef DEBUG
			printf("(No es xpn) insFdTable devuelve fdret=-1\n");
#endif
			return(-1);
		}
		return(fdret);
	} // Else
}

int chdir(const char *path)
	{
	int (* new_chdir)( char * );

#ifdef DEBUG
	printf("antes de chdir....\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_chdir((char *)(path+strlen(xpn_adaptor_partition_prefix))));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_chdir=dlsym(RTLD_NEXT,"chdir");
		new_chdir=(int (*)( char * ))dlsym(RTLD_NEXT,"chdir");
		if(new_chdir==NULL)
		{
			return(-1);
		}
		return(new_chdir((char *)path));
	} // Else
}

/**************************************************
GETCWD TIENE MUCHA CHICHA...PA LUEGO
***************************************************
char *getcwd(char *path, size_t size)
{
	int (* new_getcwd)( char *, size_t );

#ifdef DEBUG
	printf("antes de getcwd...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_chdir(path+strlen(xpn_adaptor_partition_prefix)));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_chdir=dlsym(RTLD_NEXT,"getcwd");
		new_chdir=(int (*)( char *, size_t ))dlsym(RTLD_NEXT,"getcwd");
		if(new_chdir==NULL)
		{
			return(-1);
		}
		return(new_chdir(path));
	} // Else
}

*******************************************************/

int mkdir(const char *path, mode_t mode)
{
	int (* new_mkdir)( char *, mode_t );

#ifdef DEBUG
	printf("antes de mkdir...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_mkdir((char *)(path+strlen(xpn_adaptor_partition_prefix)),mode));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_mkdir=dlsym(RTLD_NEXT,"mkdir");
		new_mkdir=(int (*)( char *, mode_t ))dlsym(RTLD_NEXT,"mkdir");
		if(new_mkdir==NULL)
		{
			return(-1);
		}
		return(new_mkdir((char *)path,mode));
	} // Else
}

int rmdir(const char *path)
{
	int (* new_rmdir)( char * );

#ifdef DEBUG
	printf("antes de rmdir...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_rmdir((char *)(path+strlen(xpn_adaptor_partition_prefix))));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_rmdir=dlsym(RTLD_NEXT,"rmdir");
		new_rmdir=(int (*)( char * ))dlsym(RTLD_NEXT,"rmdir");
		if(new_rmdir==NULL)
		{
			return(-1);
		}
		return(new_rmdir((char *)path));
	} // Else
}

int unlink(const char *path)
	{
	int (* new_unlink)( char * );

#ifdef DEBUG
	printf("antes de unlink...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_unlink((char *)(path+strlen(xpn_adaptor_partition_prefix))));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_unlink=dlsym(RTLD_NEXT,"unlink");
		new_unlink=(int (*)( char * ))dlsym(RTLD_NEXT,"unlink");
		if(new_unlink==NULL)
		{
			return(-1);
		}
		return(new_unlink((char *)path));
	} // Else
}

int chown(const char *path, uid_t owner, gid_t group)
{
	int (* new_chown)( char *, uid_t, gid_t );

#ifdef DEBUG
	printf("antes de chown...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_chown((char *)(path+strlen(xpn_adaptor_partition_prefix)), owner, group));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_chown=dlsym(RTLD_NEXT,"chown");
		new_chown=(int (*)( char *, uid_t, gid_t ))dlsym(RTLD_NEXT,"chown");
		if(new_chown==NULL)
		{
			return(-1);
		}
		return(new_chown((char *)path, owner, group));
	} // Else
}

int ftruncate(int fildes, off_t length)
{
	int (* new_ftruncate)( int, off_t );

#ifdef DEBUG
	printf("antes de ftruncate...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_ftruncate(fdstable[fildes]-PLUSXPN,length));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_ftruncate=dlsym(RTLD_NEXT,"ftruncate");
		new_ftruncate=(int (*)( int, off_t ))dlsym(RTLD_NEXT,"ftruncate");
		if(new_ftruncate==NULL)
		{
			return(-1);
		}
		return(new_ftruncate(fdstable[fildes],length));
	} // Else
}

int dup(int fildes)
{
	int (* new_dup)( int );

#ifdef DEBUG
	printf("antes de dup...\n");
#endif

	xpn_adaptor_keepInit ();//FALTABA///////////////////////////////////////////////////

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_dup(fdstable[fildes]-PLUSXPN));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_dup=dlsym(RTLD_NEXT,"dup");
		new_dup=(int (*)( int ))dlsym(RTLD_NEXT,"dup");
		if(new_dup==NULL)
		{
			return(-1);
		}
		return(new_dup(fdstable[fildes]));
	} // Else
}

int dup2(int fildes, int fildes2)
{
	int (* new_dup2)( int, int );

#ifdef DEBUG
	printf("antes de dup2...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_dup2(fdstable[fildes]-PLUSXPN, fildes2));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_dup2=dlsym(RTLD_NEXT,"dup2");
		new_dup2=(int (*)( int, int ))dlsym(RTLD_NEXT,"dup2");
		if(new_dup2==NULL)
		{
			return(-1);
		}
		return(new_dup2(fdstable[fildes],fildes2));
	} // Else
}

DIR *opendir(const char *dirname)
{
	DIR *(* new_opendir)( char * );
	DIR *ret;
	int fd,fdret;

#ifdef DEBUG
	printf("antes de opendir...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,dirname,strlen(xpn_adaptor_partition_prefix)))
	{
		ret=xpn_opendir((char *)(dirname+strlen(xpn_adaptor_partition_prefix)));
		memcpy(&fd, ret,sizeof(int));
		fdret=insFdTable(fd+PLUSXPN);
		if(fdret==-1)
		{
			return(NULL);
		}
		memcpy(ret,&fd,sizeof(int));
		return(ret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_opendir=dlsym(RTLD_NEXT,"opendir");
		new_opendir=(DIR *(*)( char * ))dlsym(RTLD_NEXT,"opendir");
		if(new_opendir==NULL)
		{
			return(NULL);
		}
		ret=(DIR *) new_opendir((char *)dirname);
		memcpy(&fd, ret,sizeof(int));
		fdret=insFdTable(fd);
		if(fdret==-1)
		{
			return(NULL);
		}
		memcpy(ret,&fd,sizeof(int));
		return(ret);
	} // Else
}


struct dirent *readdir(DIR *dirp)
{
	struct dirent *(* new_readdir)( DIR * );
	int fd,fdaux;
	struct dirent *ret;

#ifdef DEBUG
	printf("antes de readdir...\n");
#endif

	xpn_adaptor_keepInit ();

	memcpy(&fd, dirp,sizeof(int));

	if(fdstable[fd] >= PLUSXPN)
	{
		fdaux=fdstable[fd]-PLUSXPN;
		memcpy(dirp,&(fdaux),sizeof(int));
		ret=xpn_readdir(dirp);
		memcpy(dirp,&fd,sizeof(int));
		return(ret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_readdir=dlsym(RTLD_NEXT,"readdir");
		new_readdir=(struct dirent *(*)( DIR * ))dlsym(RTLD_NEXT,"readdir");
		if(new_readdir==NULL)
		{
			return(NULL);
		}
		memcpy(dirp,&(fdstable[fd]),sizeof(int));
		ret=new_readdir(dirp);
		memcpy(dirp,&fd,sizeof(int));
	} // Else
	return(ret);////////////////////////////////////////////////////////////Faltaba
}

int closedir(DIR *dirp)
{
	int (* new_closedir)( DIR * );
	int fd,ret;

#ifdef DEBUG
	printf("antes de closedir...\n");
#endif

	xpn_adaptor_keepInit ();

	memcpy(&fd, dirp,sizeof(int));

	if(fdsdirtable[fd]>=PLUSXPN)
	{
		ret=xpn_closedir(dirp);
		if (ret==0)
		{
			fdsdirtable[fd]=-1;
		}
		return(ret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_closedir=dlsym(RTLD_NEXT,"opendir");
		new_closedir=(int (*)( DIR * ))dlsym(RTLD_NEXT,"opendir");
		if(new_closedir==NULL)
		{
			return(-1);
		}
		ret=new_closedir(dirp);
		if(ret==0)
		{
			fdsdirtable[fd]=-1;
		}
		return(ret);
	} // Else
}


//int lstat64(const char *path, struct stat64 *buf){
int __lxstat64(int ver, const char *path, struct stat64 *buf)
{
	int (* new_lstat64)( int, char *, struct stat64 * );
	int ret;
	struct stat st;

	printf("antes de lstat64... %s\n",path);
#ifdef DEBUG
	printf("antes de lstat64... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		ret = xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), &st);
#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(ret<0){
			return(-1);
		}
		/********************************/
		buf->st_dev	= (__dev_t)st.st_dev;
		buf->__st_ino	= (__ino_t)st.st_ino;
		buf->st_mode	= (__mode_t)st.st_mode;
		buf->st_nlink	= (__nlink_t)st.st_nlink;
		buf->st_uid	= (__uid_t)st.st_uid;
		buf->st_gid	= (__gid_t)st.st_gid;
		buf->st_rdev	= (__dev_t)st.st_rdev;
//		buf->__pad2	= st.st_;
		buf->st_size	= (__off64_t)st.st_size;
		buf->st_blksize	= (__blksize_t)st.st_blksize;
		buf->st_blocks 	= (__blkcnt64_t)st.st_blocks;
		buf->st_atime	= (__time_t)st.st_atime;
//		buf->__unused1;
		buf->st_mtime	= (__time_t)st.st_mtime;
//		buf->__unused2;
		buf->st_ctime	= (__time_t)st.st_ctime;
//		buf->__unused3 =
		buf->st_ino	= (__ino64_t)st.st_ino;

		return 0;
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_lstat64=dlsym(RTLD_NEXT,"lstat64");
		new_lstat64=(int (*)( int, char *, struct stat64 * ))dlsym(RTLD_NEXT,"__lxstat64");
		if(new_lstat64==NULL)
		{
			return(-1);
		}
		return(new_lstat64(ver, (char *)path, buf));
	} // Else
}

//int stat64(const char *path, struct stat64 *buf)
int __xstat64(int ver, const char *path, struct stat64 *buf)
{
	int (* new_stat64)( int, char *, struct stat64 * );
	int ret;
	struct stat st;

	printf("antes de stat64... %s\n",path);
#ifdef DEBUG
	printf("antes de stat64... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		ret = xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), &st);
#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(ret<0){
			return(-1);
		}
		/********************************/
		buf->st_dev 	= (__dev_t)st.st_dev;
		buf->__st_ino	= (__ino_t)st.st_ino;
		buf->st_mode	= (__mode_t)st.st_mode;
		buf->st_nlink	= (__nlink_t)st.st_nlink;
		buf->st_uid	= (__uid_t)st.st_uid;
		buf->st_gid	= (__gid_t)st.st_gid;
		buf->st_rdev	= (__dev_t)st.st_rdev;
//		buf->__pad2	= st.st_;
		buf->st_size	= (__off64_t)st.st_size;
		buf->st_blksize 	= (__blksize_t)st.st_blksize;
		buf->st_blocks 	= (__blkcnt64_t)st.st_blocks;
		buf->st_atime 	= (__time_t)st.st_atime;
//		buf->__unused1;
		buf->st_mtime 	= (__time_t)st.st_mtime;
//		buf->__unused2;
		buf->st_ctime 	= (__time_t)st.st_ctime;
//		buf->__unused3 =
		buf->st_ino 	= (__ino64_t)st.st_ino;

		return 0;
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_stat64=dlsym(RTLD_NEXT,"stat64");
		new_stat64=(int (*)( int, char *, struct stat64 * ))dlsym(RTLD_NEXT,"__xstat64");
		if(new_stat64==NULL)
		{
			return(-1);
		}
		return(new_stat64(ver, (char *)path, buf));/////////////// ESTO PETA
	} // Else
}




//int fstat64(int fildes, struct stat64 *buf)
int __fxstat64(int fildes, struct stat64 *buf)
{
	int (* new_fstat64)( int, struct stat64 * );
	int ret;
	struct stat st;


	printf("antes de fstat64...%d\n",fildes);
#ifdef DEBUG
	printf("antes de fstat64...%d\n",fildes);
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		ret = xpn_fstat(fdstable[fildes]-PLUSXPN, &st);
		if(ret<0){
			return(-1);
		}
		/*******************************/
		buf->st_dev 	= (__dev_t)st.st_dev;
		buf->__st_ino	= (__ino_t)st.st_ino;
		buf->st_mode	= (__mode_t)st.st_mode;
		buf->st_nlink	= (__nlink_t)st.st_nlink;
		buf->st_uid	= (__uid_t)st.st_uid;
		buf->st_gid	= (__gid_t)st.st_gid;
		buf->st_rdev	= (__dev_t)st.st_rdev;
//		buf->__pad2	= st.st_;
		buf->st_size	= (__off64_t)st.st_size;
		buf->st_blksize 	= (__blksize_t)st.st_blksize;
		buf->st_blocks 	= (__blkcnt64_t)st.st_blocks;
		buf->st_atime 	= (__time_t)st.st_atime;
//		buf->__unused1;
		buf->st_mtime 	= (__time_t)st.st_mtime;
//		buf->__unused2;
		buf->st_ctime 	= (__time_t)st.st_ctime;
//		buf->__unused3 = ;
		buf->st_ino 	= (__ino64_t)st.st_ino;

		return 0;
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_fstat64=dlsym(RTLD_NEXT,"fstat64");
		new_fstat64=(int (*)( int, struct stat64 * ))dlsym(RTLD_NEXT,"__fxstat64");
		if(new_fstat64==NULL)
		{
			return(-1);
		}
		return(new_fstat64(fdstable[fildes],buf));
	} // Else
}




//int lstat(const char *path, struct stat *buf)
int __lxstat(int ver, const char *path, struct stat *buf)
{
	int (* new_lstat)( int, char *, struct stat * );

#ifdef DEBUG
	printf("antes de lstat...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), buf));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_lstat=dlsym(RTLD_NEXT,"lstat");
		new_lstat=(int (*)( int, char *, struct stat * ))dlsym(RTLD_NEXT,"__lxstat");
		if(new_lstat==NULL)
		{
			return(-1);
		}
		return(new_lstat(ver, (char *)path, buf));
	} // Else
}


//int stat(const char *path, struct stat *buf)
//int __stat(int ver, const char *path, struct stat *buf)
int __xstat(int ver, const char *path, struct stat *buf)
{
	int (* new_stat)( int, char *, struct stat * );

#ifdef DEBUG
	printf("antes de stat...\n");
	printf("stat...path total=>%s\n",path);
	printf("stat...prefix=>%d\n",strlen(xpn_adaptor_partition_prefix));
	printf("stat...path=>%s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), buf));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_stat=dlsym(RTLD_NEXT,"__xstat");
		new_stat=(int (*)( int, char *, struct stat * ))dlsym(RTLD_NEXT,"__xstat");
		if(new_stat==NULL)
		{
#ifdef DEBUG
			printf("stat...devolvemos -1\n");
#endif
			return(-1);
		}
#ifdef DEBUG
		printf("stat...llegamos al ultimo return\n");
		printf("stat...path=>%s\n",path);
#endif
	        return(syscall(18,path,buf));/////////////// ESTO PETA -> Devuelve -1
		//return(new_stat((char *)path, buf));
	} // Else
}

//int fstat(int fildes, struct stat *buf)
int __fxstat(int ver, int fildes, struct stat *buf)
{
	int (* new_fstat)( int, int, struct stat * );

#ifdef DEBUG
	printf("antes de fstat...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_fstat(fdstable[fildes]-PLUSXPN,buf));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_fstat=dlsym(RTLD_NEXT,"fstat");
		new_fstat=(int (*)( int, int, struct stat * ))dlsym(RTLD_NEXT,"__fxstat");
		if(new_fstat==NULL)
		{
			return(-1);
		}
		return(new_fstat(ver, fdstable[fildes], buf));
	} // Else
}




int chmod(const char *path, mode_t mode)
{
	int (* new_chmod)( char *, mode_t );

#ifdef DEBUG
	printf("antes de chmod...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_chmod((char *)(path+strlen(xpn_adaptor_partition_prefix)), mode));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_chmod=dlsym(RTLD_NEXT,"chmod");
		new_chmod=(int (*)( char *, mode_t ))dlsym(RTLD_NEXT,"chmod");
		if(new_chmod==NULL)
		{
			return(-1);
		}
		return(new_chmod((char *)path, mode));
	} // Else
}

int fchmod(int fildes, mode_t mode)
{
	int (* new_fchmod)( int, mode_t );

#ifdef DEBUG
	printf("antes de fchmod...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_fchmod(fdstable[fildes]-PLUSXPN,mode));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_fchmod=dlsym(RTLD_NEXT,"fchmod");
		new_fchmod=(int (*)( int, mode_t ))dlsym(RTLD_NEXT,"fchmod");
		if(new_fchmod==NULL)
		{
			return(-1);
		}
		return(new_fchmod(fdstable[fildes],mode));
	} // Else
}

ssize_t read(int fildes, void *buf, size_t nbyte)
{
	ssize_t (* new_read)( int, void *, size_t );

#ifdef DEBUG
	printf("antes de read...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_read(fdstable[fildes]-PLUSXPN, buf, nbyte));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_read=dlsym(RTLD_NEXT,"read");
		new_read=(ssize_t (*)( int, void *, size_t ))dlsym(RTLD_NEXT,"read");
		if(new_read==NULL)
		{
			return(-1);
		}
		return(new_read(fdstable[fildes],buf, nbyte));
	} // Else
}

//ssize_t write(int fildes, void *buf, size_t nbyte)
ssize_t write(int fildes, const void *buf, size_t nbyte)
{
	ssize_t (* new_write)( int, void *, size_t );

#ifdef DEBUG
	printf("antes de write...\n");
#endif

	xpn_adaptor_keepInit ();


	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_write(fdstable[fildes]-PLUSXPN, (void *)buf, nbyte));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_write=dlsym(RTLD_NEXT,"write");
		new_write=(ssize_t (*)( int, void *, size_t ))dlsym(RTLD_NEXT,"write");
		if(new_write==NULL)
		{
			return(-1);
		}
		return(new_write(fdstable[fildes], (void *)buf, nbyte));
	} // Else
}

off_t lseek(int fildes, off_t offset, int whence)
{
	off_t (* new_lseek)( int, off_t , int );

#ifdef DEBUG
	printf("antes de lseek...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_lseek(fdstable[fildes]-PLUSXPN, offset, whence));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_lseek=dlsym(RTLD_NEXT,"lseek");
		new_lseek=(off_t (*)( int, off_t , int ))dlsym(RTLD_NEXT,"lseek");
		if(new_lseek==NULL)
		{
			return(-1);
		}
		return(new_lseek(fdstable[fildes],offset, whence));
	} // Else
}

/*
int utime(char *path, struct utimbuf *times)
{
	int (* new_utime)( char *, struct utimbuf );

#ifdef DEBUG
	printf("antes de utime...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_utime(path+strlen(xpn_adaptor_partition_prefix), times));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_utime=dlsym(RTLD_NEXT,"utime");
		new_utime=(int (*)( char *, struct utimbuf ))dlsym(RTLD_NEXT,"utime");
		if(new_utime==NULL)
		{
			return(-1);
		}
		return(new_utime(path, times));
	} // Else
}
*/
#include "xpn_lib.h"
//#include <stddef.h>
//#include <sys/stat.h>

int   xpn_adaptor_initCalled = 0 ;
char *xpn_adaptor_flog_name  = "/tmp/EXPAND.LOG" ;
char *xpn_adaptor_partition_prefix = "/xpn/" ;
int   xpn_adaptor_fdshift = 64;

char *varenv;



void xpn_adaptor_log ( char * msg, ... )
{
	FILE *flog;
	va_list vargs;

	va_start(vargs,msg);
	flog = fopen(xpn_adaptor_flog_name,"a+");
	if (NULL != flog) {
		vfprintf(flog,msg,vargs);
		fclose(flog);
	}
	va_end(vargs);
}

void xpn_adaptor_keepInit ( void )
{
	int ret,i;

#ifdef DEBUG
	printf("xpn_init:\n");
#endif
	if (0==xpn_adaptor_initCalled)
	{
		ret = xpn_init();
		if (ret < 0)
		{
			printf("xpn_init: Expand couldn't be initialized\n");
			/*xpn_adaptor_log("xpn_init: Expand couldn't be initialized\n");*/
			xpn_adaptor_initCalled = 0;
		}
		else
		{
			xpn_adaptor_initCalled = 1;
		}
		for(i=0;i<MAX_FDS;i++) fdstable[i]=-1;
		for(i=0;i<MAX_DIRS;i++) fdsdirtable[i]=-1;
	}
}

int insFdTable(int fd)
{
	int i;

#ifdef DEBUG
	printf("insFdTable fd = %d\n",fd);
#endif
	for(i=0;i<MAX_FDS;i++)
	{
#ifdef DEBUG
		printf("fdstable[%d]=%d\n",i,fdstable[i]);
#endif
		if(fdstable[i]==-1)
		{
			fdstable[i]=fd;
			return(i);
		}
	}
	return(-1);
}

int open(const char *path, int flags, ...)
{
	int (* new_open1)(char *, int , mode_t );
	int (* new_open2)(char *, int );
	va_list ap;
	int perm,fd,fdret;

	va_start(ap, flags);
	perm = va_arg(ap, mode_t);
	va_end(ap);

#ifdef DEBUG
	printf("antes de open.... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("1)El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
#ifdef DEBUG
	printf("El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(perm != 0)
		{
			printf("perm != 0");
			//fd=xpn_open(path+strlen(xpn_adaptor_partition_prefix),flags,perm);
			fd=xpn_open((char *)(path+strlen(xpn_adaptor_partition_prefix)),flags,perm);
			//fd=xpn_open((char *)(path),flags,perm);
		}
		else
		{
			printf("perm == 0");
			//fd=xpn_open(path+strlen(xpn_adaptor_partition_prefix),flags);
			fd=xpn_open((char *)(path+strlen(xpn_adaptor_partition_prefix)),flags);
			//fd=xpn_open((char *)(path),flags);
		}
		if(fd<0)
		{
			return(-1);
		}
		fdret=insFdTable(fd+PLUSXPN);
		if(fdret==-1)
		{
			return(-1);
		}
		return(fdret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
#ifdef DEBUG
		printf("El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
		printf("perm = %d\n",perm);
#endif
		if(perm != 0)
		{
			//new_open1=dlsym(RTLD_NEXT,"open");
			new_open1=(int (*)(char *, int , mode_t ))dlsym(RTLD_NEXT,"open");
			if(new_open1==NULL){
#ifdef DEBUG
				printf("open1 = NULL\n");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes open1\n");
#endif
			fd=new_open1((char *)path,flags,perm);
			if(fd<0){
#ifdef DEBUG
				printf("open1 = %d\n",fd);
				perror("open1");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes insertar en tabla\n");
#endif
			fdret=insFdTable(fd);
			if(fdret==-1) {
				return(-1);
			}
			return(fdret);
		}
		else
		{
			//new_open2=dlsym(RTLD_NEXT,"open");
			new_open2=(int (*)(char *, int ))dlsym(RTLD_NEXT,"open");
			if(new_open2==NULL)
			{
#ifdef DEBUG
				printf("open2 = NULL\n");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes open2\n");
#endif
			fd=new_open2((char *)path,flags);
			if(fd<0){
				return(-1);
			}
			fdret=insFdTable(fd);
			if(fdret==-1)
			{
			      return(-1);
			}
			return(fdret);
		}
	}// Else
}

int open64(const char *path, int flags, ...)
{
	int (* new_open1)(char *, int , mode_t );
	int (* new_open2)(char *, int );
	va_list ap;
	int perm,fd,fdret;

	va_start(ap, flags);
	perm = va_arg(ap, mode_t);
	va_end(ap);

#ifdef DEBUG
	printf("antes de open64.... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("1)El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
#ifdef DEBUG
	printf("El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(perm != 0)
		{
			printf("perm != 0");
			//fd=xpn_open(path+strlen(xpn_adaptor_partition_prefix),flags,perm);
			fd=xpn_open((char *)(path+strlen(xpn_adaptor_partition_prefix)),flags,perm);
			//fd=xpn_open((char *)(path),flags,perm);
		}
		else
		{
			printf("perm == 0");
			//fd=xpn_open(path+strlen(xpn_adaptor_partition_prefix),flags);
			fd=xpn_open((char *)(path+strlen(xpn_adaptor_partition_prefix)),flags);
			//fd=xpn_open((char *)(path),flags);
		}
		if(fd<0)
		{
			return(-1);
		}
		fdret=insFdTable(fd+PLUSXPN);
		if(fdret==-1)
		{
			return(-1);
		}
		return(fdret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
#ifdef DEBUG
		printf("El path es => %s\n",path+strlen(xpn_adaptor_partition_prefix));
		printf("perm = %d\n",perm);
#endif
		if(perm != 0)
		{
			//new_open1=dlsym(RTLD_NEXT,"open");
			new_open1=(int (*)(char *, int , mode_t ))dlsym(RTLD_NEXT,"open64");
			if(new_open1==NULL){
#ifdef DEBUG
				printf("open1 = NULL\n");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes open1\n");
#endif
			fd=new_open1((char *)path,flags,perm);
			if(fd<0){
#ifdef DEBUG
				printf("open1 = %d\n",fd);
				perror("open1");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes insertar en tabla\n");
#endif
			fdret=insFdTable(fd);
			if(fdret==-1) {
				return(-1);
			}
			return(fdret);
		}
		else
		{
			//new_open2=dlsym(RTLD_NEXT,"open");
			new_open2=(int (*)(char *, int ))dlsym(RTLD_NEXT,"open64");
			if(new_open2==NULL)
			{
#ifdef DEBUG
				printf("open2 = NULL\n");
#endif
				return(-1);
			}
#ifdef DEBUG
			printf("antes open2\n");
#endif
			fd=new_open2((char *)path,flags);
			if(fd<0){
				return(-1);
			}
			fdret=insFdTable(fd);
			if(fdret==-1)
			{
			      return(-1);
			}
			return(fdret);
		}
	}// Else
}

int close(int fd){
	int (* new_close)(int);
	int ret;
#ifdef DEBUG
	int i;
#endif

#ifdef DEBUG
	printf("antes de close....\n");
	for(i=0;i<10;i++) printf("fdstable[%d]=%d\n",i,fdstable[i]);
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fd]>=PLUSXPN)
	{
		ret=xpn_close(fdstable[fd]-PLUSXPN);
		if(ret==0) fdstable[fd]=-1;	// This normally will be executed, but if close
						// fails, ret<0, and we don't want to lose the
						// reference to the handler yet
		return(ret);
	}
	else // Not an XPN partition. We must link with the standard library
	{
		//new_close=dlsym(RTLD_NEXT,"close");
		new_close=(int (*)(int))dlsym(RTLD_NEXT,"close");
#ifdef DEBUG
		printf("close: dlsym devuelve %d\n",(int)new_close);
#endif
		if(new_close==NULL){
			//printf("close: dlsym devuelve 0\n");
			return(-1);
		}
		ret=new_close(fdstable[fd]);
#ifdef DEBUG
		printf("close: new_close devuelve %d\n",ret);
#endif
		if(ret==0) fdstable[fd]=-1;	// This normally will be executed, but if close
						// fails, ret<0, and we don't want to lose the
						// reference to the handler yet
		//ret=syscall(6,fdstable[fd]);
		//printf("close: syscall(6,fdstable[%d]=%d) devuelve %d\n",fd,fdstable[fd],ret);
		return(ret);
	}// Else
}

int creat(const char *path, mode_t mode)
{
	int (* new_creat)(const char *, mode_t );
	int fd,fdret;
#ifdef DEBUG
	int i;
#endif

#ifdef DEBUG
	printf("antes de creat....\n");
#endif

	xpn_adaptor_keepInit ();//FALTABA///////////////////////////////////////////////////

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
#ifdef DEBUG
		printf("ES EXPAND!\n");
#endif
		fd=xpn_creat((char *)(path+strlen(xpn_adaptor_partition_prefix)),mode);
#ifdef DEBUG
		printf("El archivo es %s",(char *)(path+strlen(xpn_adaptor_partition_prefix)));///////////////
#endif
		if(fd<0){
#ifdef DEBUG
			printf("xpn_creat devuelve fd<0: %d\n",fd);
#endif
			return(-1);
		}
		fdret=insFdTable(fd+PLUSXPN);
		if(fdret==-1){
#ifdef DEBUG
			printf("(Es xpn) insFdTable devuelve fdret=-1\n");
#endif
			return(-1);
		}
		return(fdret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
#ifdef DEBUG
		printf("NO ES EXPAND!\n");
#endif
		//new_creat=dlsym(RTLD_NEXT,"creat");
		new_creat=(int (*)(const char *, mode_t ))dlsym(RTLD_NEXT,"creat");
		if(new_creat==NULL)
		{
#ifdef DEBUG
			printf("dlsym devuelve new_creat==NULL\n");
#endif
			return(-1);
		}
		fd=new_creat(path,mode);
		//printf("fd=new_creat(path,mode) devuelve %d\n",fd);
		if(fd<0)
		{
#ifdef DEBUG
			printf("new_creat devuelve fd=%d\n",fd);
#endif
			return(-1);
		}
		fdret=insFdTable(fd);
#ifdef DEBUG
		printf("dentro de creat\n");
		for(i=0;i<10;i++) printf("fdstable[%d]=%d\n",i,fdstable[i]);
#endif
		if(fdret==-1)
		{
#ifdef DEBUG
			printf("(No es xpn) insFdTable devuelve fdret=-1\n");
#endif
			return(-1);
		}
		return(fdret);
	} // Else
}

int chdir(const char *path)
	{
	int (* new_chdir)( char * );

#ifdef DEBUG
	printf("antes de chdir....\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_chdir((char *)(path+strlen(xpn_adaptor_partition_prefix))));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_chdir=dlsym(RTLD_NEXT,"chdir");
		new_chdir=(int (*)( char * ))dlsym(RTLD_NEXT,"chdir");
		if(new_chdir==NULL)
		{
			return(-1);
		}
		return(new_chdir((char *)path));
	} // Else
}

/**************************************************
GETCWD TIENE MUCHA CHICHA...PA LUEGO
***************************************************
char *getcwd(char *path, size_t size)
{
	int (* new_getcwd)( char *, size_t );

#ifdef DEBUG
	printf("antes de getcwd...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_chdir(path+strlen(xpn_adaptor_partition_prefix)));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_chdir=dlsym(RTLD_NEXT,"getcwd");
		new_chdir=(int (*)( char *, size_t ))dlsym(RTLD_NEXT,"getcwd");
		if(new_chdir==NULL)
		{
			return(-1);
		}
		return(new_chdir(path));
	} // Else
}

*******************************************************/

int mkdir(const char *path, mode_t mode)
{
	int (* new_mkdir)( char *, mode_t );

#ifdef DEBUG
	printf("antes de mkdir...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_mkdir((char *)(path+strlen(xpn_adaptor_partition_prefix)),mode));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_mkdir=dlsym(RTLD_NEXT,"mkdir");
		new_mkdir=(int (*)( char *, mode_t ))dlsym(RTLD_NEXT,"mkdir");
		if(new_mkdir==NULL)
		{
			return(-1);
		}
		return(new_mkdir((char *)path,mode));
	} // Else
}

int rmdir(const char *path)
{
	int (* new_rmdir)( char * );

#ifdef DEBUG
	printf("antes de rmdir...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_rmdir((char *)(path+strlen(xpn_adaptor_partition_prefix))));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_rmdir=dlsym(RTLD_NEXT,"rmdir");
		new_rmdir=(int (*)( char * ))dlsym(RTLD_NEXT,"rmdir");
		if(new_rmdir==NULL)
		{
			return(-1);
		}
		return(new_rmdir((char *)path));
	} // Else
}

int unlink(const char *path)
	{
	int (* new_unlink)( char * );

#ifdef DEBUG
	printf("antes de unlink...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_unlink((char *)(path+strlen(xpn_adaptor_partition_prefix))));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_unlink=dlsym(RTLD_NEXT,"unlink");
		new_unlink=(int (*)( char * ))dlsym(RTLD_NEXT,"unlink");
		if(new_unlink==NULL)
		{
			return(-1);
		}
		return(new_unlink((char *)path));
	} // Else
}

int chown(const char *path, uid_t owner, gid_t group)
{
	int (* new_chown)( char *, uid_t, gid_t );

#ifdef DEBUG
	printf("antes de chown...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_chown((char *)(path+strlen(xpn_adaptor_partition_prefix)), owner, group));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_chown=dlsym(RTLD_NEXT,"chown");
		new_chown=(int (*)( char *, uid_t, gid_t ))dlsym(RTLD_NEXT,"chown");
		if(new_chown==NULL)
		{
			return(-1);
		}
		return(new_chown((char *)path, owner, group));
	} // Else
}

int ftruncate(int fildes, off_t length)
{
	int (* new_ftruncate)( int, off_t );

#ifdef DEBUG
	printf("antes de ftruncate...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_ftruncate(fdstable[fildes]-PLUSXPN,length));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_ftruncate=dlsym(RTLD_NEXT,"ftruncate");
		new_ftruncate=(int (*)( int, off_t ))dlsym(RTLD_NEXT,"ftruncate");
		if(new_ftruncate==NULL)
		{
			return(-1);
		}
		return(new_ftruncate(fdstable[fildes],length));
	} // Else
}

int dup(int fildes)
{
	int (* new_dup)( int );

#ifdef DEBUG
	printf("antes de dup...\n");
#endif

	xpn_adaptor_keepInit ();//FALTABA///////////////////////////////////////////////////

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_dup(fdstable[fildes]-PLUSXPN));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_dup=dlsym(RTLD_NEXT,"dup");
		new_dup=(int (*)( int ))dlsym(RTLD_NEXT,"dup");
		if(new_dup==NULL)
		{
			return(-1);
		}
		return(new_dup(fdstable[fildes]));
	} // Else
}

int dup2(int fildes, int fildes2)
{
	int (* new_dup2)( int, int );

#ifdef DEBUG
	printf("antes de dup2...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_dup2(fdstable[fildes]-PLUSXPN, fildes2));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_dup2=dlsym(RTLD_NEXT,"dup2");
		new_dup2=(int (*)( int, int ))dlsym(RTLD_NEXT,"dup2");
		if(new_dup2==NULL)
		{
			return(-1);
		}
		return(new_dup2(fdstable[fildes],fildes2));
	} // Else
}

DIR *opendir(const char *dirname)
{
	DIR *(* new_opendir)( char * );
	DIR *ret;
	int fd,fdret;

#ifdef DEBUG
	printf("antes de opendir...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,dirname,strlen(xpn_adaptor_partition_prefix)))
	{
		ret=xpn_opendir((char *)(dirname+strlen(xpn_adaptor_partition_prefix)));
		memcpy(&fd, ret,sizeof(int));
		fdret=insFdTable(fd+PLUSXPN);
		if(fdret==-1)
		{
			return(NULL);
		}
		memcpy(ret,&fd,sizeof(int));
		return(ret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_opendir=dlsym(RTLD_NEXT,"opendir");
		new_opendir=(DIR *(*)( char * ))dlsym(RTLD_NEXT,"opendir");
		if(new_opendir==NULL)
		{
			return(NULL);
		}
		ret=(DIR *) new_opendir((char *)dirname);
		memcpy(&fd, ret,sizeof(int));
		fdret=insFdTable(fd);
		if(fdret==-1)
		{
			return(NULL);
		}
		memcpy(ret,&fd,sizeof(int));
		return(ret);
	} // Else
}


struct dirent *readdir(DIR *dirp)
{
	struct dirent *(* new_readdir)( DIR * );
	int fd,fdaux;
	struct dirent *ret;

#ifdef DEBUG
	printf("antes de readdir...\n");
#endif

	xpn_adaptor_keepInit ();

	memcpy(&fd, dirp,sizeof(int));

	if(fdstable[fd] >= PLUSXPN)
	{
		fdaux=fdstable[fd]-PLUSXPN;
		memcpy(dirp,&(fdaux),sizeof(int));
		ret=xpn_readdir(dirp);
		memcpy(dirp,&fd,sizeof(int));
		return(ret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_readdir=dlsym(RTLD_NEXT,"readdir");
		new_readdir=(struct dirent *(*)( DIR * ))dlsym(RTLD_NEXT,"readdir");
		if(new_readdir==NULL)
		{
			return(NULL);
		}
		memcpy(dirp,&(fdstable[fd]),sizeof(int));
		ret=new_readdir(dirp);
		memcpy(dirp,&fd,sizeof(int));
	} // Else
	return(ret);////////////////////////////////////////////////////////////Faltaba
}

int closedir(DIR *dirp)
{
	int (* new_closedir)( DIR * );
	int fd,ret;

#ifdef DEBUG
	printf("antes de closedir...\n");
#endif

	xpn_adaptor_keepInit ();

	memcpy(&fd, dirp,sizeof(int));

	if(fdsdirtable[fd]>=PLUSXPN)
	{
		ret=xpn_closedir(dirp);
		if (ret==0)
		{
			fdsdirtable[fd]=-1;
		}
		return(ret);
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_closedir=dlsym(RTLD_NEXT,"opendir");
		new_closedir=(int (*)( DIR * ))dlsym(RTLD_NEXT,"opendir");
		if(new_closedir==NULL)
		{
			return(-1);
		}
		ret=new_closedir(dirp);
		if(ret==0)
		{
			fdsdirtable[fd]=-1;
		}
		return(ret);
	} // Else
}


//int lstat64(const char *path, struct stat64 *buf){
int __lxstat64(int ver, const char *path, struct stat64 *buf)
{
	int (* new_lstat64)( int, char *, struct stat64 * );
	int ret;
	struct stat st;

	printf("antes de lstat64... %s\n",path);
#ifdef DEBUG
	printf("antes de lstat64... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		ret = xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), &st);
#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(ret<0){
			return(-1);
		}
		/********************************/
		buf->st_dev	= (__dev_t)st.st_dev;
		buf->__st_ino	= (__ino_t)st.st_ino;
		buf->st_mode	= (__mode_t)st.st_mode;
		buf->st_nlink	= (__nlink_t)st.st_nlink;
		buf->st_uid	= (__uid_t)st.st_uid;
		buf->st_gid	= (__gid_t)st.st_gid;
		buf->st_rdev	= (__dev_t)st.st_rdev;
//		buf->__pad2	= st.st_;
		buf->st_size	= (__off64_t)st.st_size;
		buf->st_blksize	= (__blksize_t)st.st_blksize;
		buf->st_blocks 	= (__blkcnt64_t)st.st_blocks;
		buf->st_atime	= (__time_t)st.st_atime;
//		buf->__unused1;
		buf->st_mtime	= (__time_t)st.st_mtime;
//		buf->__unused2;
		buf->st_ctime	= (__time_t)st.st_ctime;
//		buf->__unused3 =
		buf->st_ino	= (__ino64_t)st.st_ino;

		return 0;
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_lstat64=dlsym(RTLD_NEXT,"lstat64");
		new_lstat64=(int (*)( int, char *, struct stat64 * ))dlsym(RTLD_NEXT,"__lxstat64");
		if(new_lstat64==NULL)
		{
			return(-1);
		}
		return(new_lstat64(ver, (char *)path, buf));
	} // Else
}

//int stat64(const char *path, struct stat64 *buf)
int __xstat64(int ver, const char *path, struct stat64 *buf)
{
	int (* new_stat64)( int, char *, struct stat64 * );
	int ret;
	struct stat st;

	printf("antes de stat64... %s\n",path);
#ifdef DEBUG
	printf("antes de stat64... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		ret = xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), &st);
#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(ret<0){
			return(-1);
		}
		/********************************/
		buf->st_dev 	= (__dev_t)st.st_dev;
		buf->__st_ino	= (__ino_t)st.st_ino;
		buf->st_mode	= (__mode_t)st.st_mode;
		buf->st_nlink	= (__nlink_t)st.st_nlink;
		buf->st_uid	= (__uid_t)st.st_uid;
		buf->st_gid	= (__gid_t)st.st_gid;
		buf->st_rdev	= (__dev_t)st.st_rdev;
//		buf->__pad2	= st.st_;
		buf->st_size	= (__off64_t)st.st_size;
		buf->st_blksize 	= (__blksize_t)st.st_blksize;
		buf->st_blocks 	= (__blkcnt64_t)st.st_blocks;
		buf->st_atime 	= (__time_t)st.st_atime;
//		buf->__unused1;
		buf->st_mtime 	= (__time_t)st.st_mtime;
//		buf->__unused2;
		buf->st_ctime 	= (__time_t)st.st_ctime;
//		buf->__unused3 =
		buf->st_ino 	= (__ino64_t)st.st_ino;

		return 0;
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_stat64=dlsym(RTLD_NEXT,"stat64");
		new_stat64=(int (*)( int, char *, struct stat64 * ))dlsym(RTLD_NEXT,"__xstat64");
		if(new_stat64==NULL)
		{
			return(-1);
		}
		return(new_stat64(ver, (char *)path, buf));/////////////// ESTO PETA
	} // Else
}




//int fstat64(int fildes, struct stat64 *buf)
int __fxstat64(int fildes, struct stat64 *buf)
{
	int (* new_fstat64)( int, struct stat64 * );
	int ret;
	struct stat st;


	printf("antes de fstat64...%d\n",fildes);
#ifdef DEBUG
	printf("antes de fstat64...%d\n",fildes);
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		ret = xpn_fstat(fdstable[fildes]-PLUSXPN, &st);
		if(ret<0){
			return(-1);
		}
		/*******************************/
		buf->st_dev 	= (__dev_t)st.st_dev;
		buf->__st_ino	= (__ino_t)st.st_ino;
		buf->st_mode	= (__mode_t)st.st_mode;
		buf->st_nlink	= (__nlink_t)st.st_nlink;
		buf->st_uid	= (__uid_t)st.st_uid;
		buf->st_gid	= (__gid_t)st.st_gid;
		buf->st_rdev	= (__dev_t)st.st_rdev;
//		buf->__pad2	= st.st_;
		buf->st_size	= (__off64_t)st.st_size;
		buf->st_blksize 	= (__blksize_t)st.st_blksize;
		buf->st_blocks 	= (__blkcnt64_t)st.st_blocks;
		buf->st_atime 	= (__time_t)st.st_atime;
//		buf->__unused1;
		buf->st_mtime 	= (__time_t)st.st_mtime;
//		buf->__unused2;
		buf->st_ctime 	= (__time_t)st.st_ctime;
//		buf->__unused3 = ;
		buf->st_ino 	= (__ino64_t)st.st_ino;

		return 0;
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_fstat64=dlsym(RTLD_NEXT,"fstat64");
		new_fstat64=(int (*)( int, struct stat64 * ))dlsym(RTLD_NEXT,"__fxstat64");
		if(new_fstat64==NULL)
		{
			return(-1);
		}
		return(new_fstat64(fdstable[fildes],buf));
	} // Else
}




//int lstat(const char *path, struct stat *buf)
int __lxstat(int ver, const char *path, struct stat *buf)
{
	int (* new_lstat)( int, char *, struct stat * );

#ifdef DEBUG
	printf("antes de lstat...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), buf));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_lstat=dlsym(RTLD_NEXT,"lstat");
		new_lstat=(int (*)( int, char *, struct stat * ))dlsym(RTLD_NEXT,"__lxstat");
		if(new_lstat==NULL)
		{
			return(-1);
		}
		return(new_lstat(ver, (char *)path, buf));
	} // Else
}


//int stat(const char *path, struct stat *buf)
//int __stat(int ver, const char *path, struct stat *buf)
int __xstat(int ver, const char *path, struct stat *buf)
{
	int (* new_stat)( int, char *, struct stat * );

#ifdef DEBUG
	printf("antes de stat...\n");
	printf("stat...path total=>%s\n",path);
	printf("stat...prefix=>%d\n",strlen(xpn_adaptor_partition_prefix));
	printf("stat...path=>%s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), buf));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_stat=dlsym(RTLD_NEXT,"__xstat");
		new_stat=(int (*)( int, char *, struct stat * ))dlsym(RTLD_NEXT,"__xstat");
		if(new_stat==NULL)
		{
#ifdef DEBUG
			printf("stat...devolvemos -1\n");
#endif
			return(-1);
		}
#ifdef DEBUG
		printf("stat...llegamos al ultimo return\n");
		printf("stat...path=>%s\n",path);
#endif
	        return(syscall(18,path,buf));/////////////// ESTO PETA -> Devuelve -1
		//return(new_stat((char *)path, buf));
	} // Else
}

//int fstat(int fildes, struct stat *buf)
int __fxstat(int ver, int fildes, struct stat *buf)
{
	int (* new_fstat)( int, int, struct stat * );

#ifdef DEBUG
	printf("antes de fstat...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_fstat(fdstable[fildes]-PLUSXPN,buf));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_fstat=dlsym(RTLD_NEXT,"fstat");
		new_fstat=(int (*)( int, int, struct stat * ))dlsym(RTLD_NEXT,"__fxstat");
		if(new_fstat==NULL)
		{
			return(-1);
		}
		return(new_fstat(ver, fdstable[fildes], buf));
	} // Else
}




int chmod(const char *path, mode_t mode)
{
	int (* new_chmod)( char *, mode_t );

#ifdef DEBUG
	printf("antes de chmod...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_chmod((char *)(path+strlen(xpn_adaptor_partition_prefix)), mode));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_chmod=dlsym(RTLD_NEXT,"chmod");
		new_chmod=(int (*)( char *, mode_t ))dlsym(RTLD_NEXT,"chmod");
		if(new_chmod==NULL)
		{
			return(-1);
		}
		return(new_chmod((char *)path, mode));
	} // Else
}

int fchmod(int fildes, mode_t mode)
{
	int (* new_fchmod)( int, mode_t );

#ifdef DEBUG
	printf("antes de fchmod...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_fchmod(fdstable[fildes]-PLUSXPN,mode));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_fchmod=dlsym(RTLD_NEXT,"fchmod");
		new_fchmod=(int (*)( int, mode_t ))dlsym(RTLD_NEXT,"fchmod");
		if(new_fchmod==NULL)
		{
			return(-1);
		}
		return(new_fchmod(fdstable[fildes],mode));
	} // Else
}

ssize_t read(int fildes, void *buf, size_t nbyte)
{
	ssize_t (* new_read)( int, void *, size_t );

#ifdef DEBUG
	printf("antes de read...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_read(fdstable[fildes]-PLUSXPN, buf, nbyte));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_read=dlsym(RTLD_NEXT,"read");
		new_read=(ssize_t (*)( int, void *, size_t ))dlsym(RTLD_NEXT,"read");
		if(new_read==NULL)
		{
			return(-1);
		}
		return(new_read(fdstable[fildes],buf, nbyte));
	} // Else
}

//ssize_t write(int fildes, void *buf, size_t nbyte)
ssize_t write(int fildes, const void *buf, size_t nbyte)
{
	ssize_t (* new_write)( int, void *, size_t );

#ifdef DEBUG
	printf("antes de write...\n");
#endif

	xpn_adaptor_keepInit ();


	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_write(fdstable[fildes]-PLUSXPN, (void *)buf, nbyte));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_write=dlsym(RTLD_NEXT,"write");
		new_write=(ssize_t (*)( int, void *, size_t ))dlsym(RTLD_NEXT,"write");
		if(new_write==NULL)
		{
			return(-1);
		}
		return(new_write(fdstable[fildes], (void *)buf, nbyte));
	} // Else
}

off_t lseek(int fildes, off_t offset, int whence)
{
	off_t (* new_lseek)( int, off_t , int );

#ifdef DEBUG
	printf("antes de lseek...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		return(xpn_lseek(fdstable[fildes]-PLUSXPN, offset, whence));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_lseek=dlsym(RTLD_NEXT,"lseek");
		new_lseek=(off_t (*)( int, off_t , int ))dlsym(RTLD_NEXT,"lseek");
		if(new_lseek==NULL)
		{
			return(-1);
		}
		return(new_lseek(fdstable[fildes],offset, whence));
	} // Else
}

/*
int utime(char *path, struct utimbuf *times)
{
	int (* new_utime)( char *, struct utimbuf );

#ifdef DEBUG
	printf("antes de utime...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_utime(path+strlen(xpn_adaptor_partition_prefix), times));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_utime=dlsym(RTLD_NEXT,"utime");
		new_utime=(int (*)( char *, struct utimbuf ))dlsym(RTLD_NEXT,"utime");
		if(new_utime==NULL)
		{
			return(-1);
		}
		return(new_utime(path, times));
	} // Else
}
*/
#include "xpn_lib.h"
#include <syscall.h>
//#include <stddef.h>
//#include <sys/stat.h>
#include <errno.h>
#include <stddef.h>
#include <sys/stat.h>
//#include "/export/home/pato11-1/users/bbergua/glibc-2.3.2/glibc-2.3.2/sysdeps/unix/sysv/linux/kernel_stat.h"

//#include "/export/home/pato11-1/users/bbergua/glibc-2.3.2/glibc-2.3.2/sysdeps/i386/sysdep.h"
#include <sys/syscall.h>
//#include "/export/home/pato11-1/users/bbergua/glibc-2.3.2/glibc-2.3.2/sysdeps/generic/bp-checks.h"

//#include "/export/home/pato11-1/users/bbergua/glibc-2.3.2/glibc-2.3.2/sysdeps/unix/sysv/linux/kernel-features.h"

//#include "/export/home/pato11-1/users/bbergua/glibc-2.3.2/glibc-2.3.2/sysdeps/unix/sysv/linux/xstatconv.c"




#if defined(RTLD_NEXT)
#define REAL_LIBC RTLD_NEXT
#else
#define REAL_LIBC ((void *) -1L)
#endif

int   xpn_adaptor_initCalled = 0 ;
char *xpn_adaptor_flog_name  = "/tmp/EXPAND.LOG" ;
char *xpn_adaptor_partition_prefix = "/xpn/" ;
int   xpn_adaptor_fdshift = 64;

char *varenv;

#define INLINE_SYSCALL(name, nr, args...) __syscall_##name (args)

void xpn_adaptor_keepInit ( void )
{
	int ret,i;

#ifdef DEBUG
	printf("xpn_init:\n");
#endif
	if (0==xpn_adaptor_initCalled)
	{
		ret = xpn_init();
		if (ret < 0)
		{
			printf("xpn_init: Expand couldn't be initialized\n");
			/*xpn_adaptor_log("xpn_init: Expand couldn't be initialized\n");*/
			xpn_adaptor_initCalled = 0;
		}
		else
		{
			xpn_adaptor_initCalled = 1;
		}
		for(i=0;i<MAX_FDS;i++) fdstable[i]=-1;
		for(i=0;i<MAX_DIRS;i++) fdsdirtable[i]=-1;
	}
}


//int lstat64(const char *path, struct stat64 *buf){
int __lxstat64(int ver, const char *path, struct stat64 *buf)
{
	int (* new_lstat64)( int, char *, struct stat64 * );
	int ret;
	struct stat st;

#ifdef DEBUG
	printf("antes de lstat64... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		ret = xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), &st);
#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(ret<0){
			return(-1);
		}
		///////////////////////////////////////////
		buf->st_dev	= (__dev_t)st.st_dev;
		buf->__st_ino	= (__ino_t)st.st_ino;
		buf->st_mode	= (__mode_t)st.st_mode;
		buf->st_nlink	= (__nlink_t)st.st_nlink;
		buf->st_uid	= (__uid_t)st.st_uid;
		buf->st_gid	= (__gid_t)st.st_gid;
		buf->st_rdev	= (__dev_t)st.st_rdev;
//		buf->__pad2	= st.st_;
		buf->st_size	= (__off64_t)st.st_size;
		buf->st_blksize	= (__blksize_t)st.st_blksize;
		buf->st_blocks 	= (__blkcnt64_t)st.st_blocks;
		buf->st_atime	= (__time_t)st.st_atime;
//		buf->__unused1;
		buf->st_mtime	= (__time_t)st.st_mtime;
//		buf->__unused2;
		buf->st_ctime	= (__time_t)st.st_ctime;
//		buf->__unused3 =
		buf->st_ino	= (__ino64_t)st.st_ino;

		return 0;
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		new_lstat64=(int (*)( int, char *, struct stat64 * ))dlsym(RTLD_NEXT,"__lxstat64");
		if(new_lstat64==NULL)
		{
			return(-1);
		}
		return(new_lstat64(ver, (char *)path, buf));
		//return(syscall(196, (char *)path, buf));
		//return(syscall(SYS_lstat64, (char *)path, buf));
	} // Else
}

//int stat64(const char *path, struct stat64 *buf)
int __xstat64(int ver, const char *path, struct stat64 *buf)
{
	int (* new_stat64)( int, char *, struct stat64 * );
	int ret;
	struct stat st;
	int retorno;

#ifdef DEBUG
	printf("antes de stat64... %s\n",path);
#endif

	xpn_adaptor_keepInit ();

#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		ret = xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), &st);
#ifdef DEBUG
	printf("path = %s\n",path+strlen(xpn_adaptor_partition_prefix));
#endif
		if(ret<0){
			return(-1);
		}
		/////////////////////////////////////////////
		buf->st_dev 	= (__dev_t)st.st_dev;
		buf->__st_ino	= (__ino_t)st.st_ino;
		buf->st_mode	= (__mode_t)st.st_mode;
		buf->st_nlink	= (__nlink_t)st.st_nlink;
		buf->st_uid	= (__uid_t)st.st_uid;
		buf->st_gid	= (__gid_t)st.st_gid;
		buf->st_rdev	= (__dev_t)st.st_rdev;
//		buf->__pad2	= st.st_;
		buf->st_size	= (__off64_t)st.st_size;
		buf->st_blksize 	= (__blksize_t)st.st_blksize;
		buf->st_blocks 	= (__blkcnt64_t)st.st_blocks;
		buf->st_atime 	= (__time_t)st.st_atime;
//		buf->__unused1;
		buf->st_mtime 	= (__time_t)st.st_mtime;
//		buf->__unused2;
		buf->st_ctime 	= (__time_t)st.st_ctime;
//		buf->__unused3 =
		buf->st_ino 	= (__ino64_t)st.st_ino;

		return 0;
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		new_stat64=(int (*)( int, char *, struct stat64 * ))dlsym(RTLD_NEXT,"__lxstat64");
		if(new_stat64==NULL)
		{
			return(-1);
		}
		//return(new_stat64(ver, (char *)path, buf));
		retorno=new_stat64(ver, (char *)path, buf);
		//printf("stat64----------------------->%o\n",buf->st_mode);
		return(retorno);
		//return(syscall(195, (char *)path, buf));
		//return(syscall(SYS_stat64, (char *)path, buf));
	} // Else
}




//int fstat64(int fildes, struct stat64 *buf)
//int __fxstat64(int fildes, struct stat64 *buf)
int __fxstat64(int ver, int fildes, struct stat64 *buf)
{
	int (* new_fstat64)( int, int, struct stat64 * );
	int ret;
	struct stat st;


#ifdef DEBUG
	printf("antes de fstat64...%d\n", fildes);
	printf("antes de fstat64...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fdstable[fildes]>=PLUSXPN)
	{
		ret = xpn_fstat(fdstable[fildes]-PLUSXPN, &st);
		if(ret<0){
			return(-1);
		}
		//////////////////////////////////////////
		buf->st_dev 	= (__dev_t)st.st_dev;
		buf->__st_ino	= (__ino_t)st.st_ino;
		buf->st_mode	= (__mode_t)st.st_mode;
		buf->st_nlink	= (__nlink_t)st.st_nlink;
		buf->st_uid	= (__uid_t)st.st_uid;
		buf->st_gid	= (__gid_t)st.st_gid;
		buf->st_rdev	= (__dev_t)st.st_rdev;
//		buf->__pad2	= st.st_;
		buf->st_size	= (__off64_t)st.st_size;
		buf->st_blksize 	= (__blksize_t)st.st_blksize;
		buf->st_blocks 	= (__blkcnt64_t)st.st_blocks;
		buf->st_atime 	= (__time_t)st.st_atime;
//		buf->__unused1;
		buf->st_mtime 	= (__time_t)st.st_mtime;
//		buf->__unused2;
		buf->st_ctime 	= (__time_t)st.st_ctime;
//		buf->__unused3 = ;
		buf->st_ino 	= (__ino64_t)st.st_ino;

		return 0;
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		new_fstat64=(int (*)( int, int, struct stat64 * ))dlsym(RTLD_NEXT,"__fxstat64");
		if(new_fstat64==NULL)
		{
			return(-1);
		}
		return(new_fstat64(ver, fildes, buf));
		//return(syscall(197, fildes, buf));
		//return(syscall(SYS_fstat64, fildes, buf));
	} // Else
}




//int lstat(const char *path, struct stat *buf)
int __lxstat(int ver, const char *path, struct stat *buf)
{
	int (* new_lstat)( int, char *, struct stat * );
	int retorno;

#ifdef DEBUG
	printf("antes de lstat...%s\n",path);
	printf("antes de lstat...\n");
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), buf));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		new_lstat=(int (*)( int, char *, struct stat * ))dlsym(RTLD_NEXT,"__lxstat");
		if(new_lstat==NULL)
		{
			return(-1);
		}
		retorno=new_lstat(ver, (char *)path, buf);
		//printf("lstat----------------------->%o\n",buf->st_mode);
		return(retorno);
		//return(new_lstat(ver, (char *)path, buf));
		//return(syscall(84,(char *)path, buf));
		//return(syscall(SYS_lstat,(char *)path, buf));
	} // Else
}


//int stat(const char *path, struct stat *buf)
//int __stat(int ver, const char *path, struct stat *buf)
int __xstat(int ver, const char *path, struct stat *buf)
{
	int (* new_stat)( int, char *, struct stat * );
	int retorno;

#ifdef DEBUG
	printf("antes de stat...%s\n",path);
#endif

	xpn_adaptor_keepInit ();

	if(!strncmp(xpn_adaptor_partition_prefix,path,strlen(xpn_adaptor_partition_prefix)))
	{
		return(xpn_stat((char *)(path+strlen(xpn_adaptor_partition_prefix)), buf));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		//new_stat=(int (*)( int, char *, struct stat * ))dlsym(RTLD_NEXT,"__xstat");
		new_stat=(int (*)( int, char *, struct stat * ))dlsym(RTLD_NEXT,"__lxstat");
		if(new_stat==NULL)
		{
#ifdef DEBUG
			printf(">>>>>>>>>>>>>>>>>>>>>>>>>new_stat es NULL<<<<<<<<<<<<<<<<<<<<<<<<\n");
			printf("stat...devolvemos -1\n");
#endif
			return(-1);
		}
		retorno=new_stat(ver, (char *)path, buf);
		//printf("stat----------------------->%o\n",buf->st_mode);
		return(retorno);
		//return(new_stat(ver, (char *)path, buf));
	        //return(syscall(18,path,buf));
	        //return(syscall(SYS_stat,path,buf));
	} // Else
}

//int fstat(int fildes, struct stat *buf)
int __fxstat(int ver, int fildes, struct stat *buf)
{
	int (* new_fstat)( int, int, struct stat * );

#ifdef DEBUG
	printf("antes de fstat...%d\n",fildes);
	printf("antes de fstat...\n");
#endif

	xpn_adaptor_keepInit ();

	if(fildes>=PLUSXPN)
	{
		return(xpn_fstat(fdstable[fildes]-PLUSXPN,buf));
	}// If xpn
	else // Not an XPN partition. We must link with the standard library
	{
		new_fstat=(int (*)( int, int, struct stat * ))dlsym(RTLD_NEXT,"__fxstat");
		if(new_fstat==NULL)
		{
			return(-1);
		}
		return(new_fstat(ver, fildes, buf));
		//return(syscall(28,fildes,buf));
		//return(syscall(SYS_fstat,fildes,buf));
	} // Else
}

int main(int argc, char *argv[]) {
	printf("Soy %d y mi LD_PRELOAD es %s\n", getpid(), getenv("LD_PRELOAD"));
	printf("Realizando execve -> ");
	execve("/bin/ls", 0, 0);
	printf("Vuelve de execve => ERROR\n");
	exit(0);
}
int main(int argc, char *argv[]) {
	printf("Soy %d y mi LD_PRELOAD es %s\n", getpid(), getenv("LD_PRELOAD"));
	printf("Realizando execve -> ");
	execve("/bin/ls", 0, 0);
	printf("Vuelve de execve => ERROR\n");
	exit(0);
}
